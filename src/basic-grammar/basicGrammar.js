/**
 * JavaScriptという言語はECMAScriptという仕様によって動作が決められています。 ECMAScriptという仕様では、どの実行環境でも共通な動作のみが定義されているため、基本的にどの実行環境でも同じ動作をします。
 * そのため、「ECMAScript」はどの実行環境でも共通の部分、「JavaScript」はECMAScriptと実行環境の固有機能も含んだ範囲というのがイメージしやすいでしょう。
 * ECMAScriptでは機能を追加する際にも後方互換性を重視している。
 */

// 大文字と小文字を区別する
// それぞれ別の変数として認識される
const name = "azu";
const NAME = "azu";

// var
// 値の再代入が可能な変数
// 同じ名前の変数を再定義できてしまい、値を上書きしてしまいます。

// 数字から始まる変数名を定義することはできない

// constは値の再代入ができないが、オブジェクトであればできてしまう。

function test() {
  console.log("test");
}

console.log(test());

// constは値の再代入ができないが、オブジェクトであればできてしまう。

function test() {
  console.log("test");
}

console.log(test());

// *** データ型 ***
// プリミティブ型（基本型）一度作成したらその値自体を変更できないというイミュータブルの特性もつ
// 真偽値（Boolean）: trueまたはfalseのデータ型
// 数値（Number）: 42 や 3.14159 などの数値のデータ型
// 巨大な整数（BigInt）: ES2020から追加された9007199254740992nなどの任意精度の整数のデータ型
// 文字列（String）: "JavaScript" などの文字列のデータ型
// undefined: 値が未定義であることを意味するデータ型
// null: 値が存在しないことを意味するデータ型
// シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型

// オブジェクト（複合型）一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持つ
// プリミティブ型以外のデータ
// オブジェクト、配列、関数、クラス、正規表現、Dateなど

// typeof演算子では、オブジェクトの詳細な種類を判定できない
console.log(typeof true); // => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof 9007199254740992n); // => "bigint"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル")); // => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { key: "value" }); // => "object"
console.log(typeof function () {}); // => "function"

// 整数リテラルには次の4種類が存在する

// 10進数: 数字の組み合わせ
// ただし、複数の数字を組み合わせた際に、先頭を0から開始すると8進数として扱われる場合があります
// 例）0、2、10
console.log(2);
// 2進数: 0b（または0B）の後ろに、0または1の数字の組み合わせ
// 例）0b0、0b10、0b1010
// 0bからはじまる2進数リテラルは、ビットを表現するのによく利用されています。
console.log(0b1);
// 8進数: 0o（または0O）の後ろに、0から7までの数字の組み合わせ
// 0o は数字のゼロと小文字アルファベットのo
// 例）0o644、0o777
// 0oからはじまる8進数リテラルは、ファイルのパーミッションを表現するのによく利用されています。
// ファイルごとに定義された、読み出し・書込みなどのアクセスに対する許可情報。
console.log(0o77);
// 16進数: 0x（または0X）の後ろに、0から9までの数字とaからfまたはAからFのアルファベットの組み合わせ
// アルファベットの大文字・小文字の違いは値には影響しません
// 例）0x30A2、0xEEFF
// 0xからはじまる16進数リテラルは、文字のコードポイントやRGB値の表現などに利用されています。
console.log(0x30a2);

// Numeric Separators
// ES2021から、数値リテラル内の区切り文字として_を追加できるNumeric Separatorsがサポートされています。
console.log(1_000_000_000);

// テンプレートリテラル
// テンプレートリテラルは、`（バッククォート）で囲んだ範囲を文字列とするリテラルです。
const str = "入れたくないかもだし";
const template = `
  複数行の
  文字列を
  ${str}
  入れたい
`;
console.log(template);

// 正規表現リテラル
const numberRegExp = /\d+/;
console.log(numberRegExp.test("123"));

// *** 演算子 ***
// べき乗を計算できる
console.log(2 ** 4); // =>16
console.log(Math.pow(2, 4)); // =>16

// 単項演算子の+はオペランドを数値に変換する（一方、数値に変換できない文字列などはNaNという特殊な値へと変換される）
// * 単項プラス演算子は文字列から数値への変換に使うべきではなく、Numberコンストラクタ関数やparseInt関数などの明示的な変換方法を使用した方がいい
console.log(typeof +"1"); // => number

// 厳密等価演算子
// オペランドがどちらもオブジェクトであるときは、 オブジェクトの参照が同じである場合に、trueを返します。
// {} は新しいオブジェクトを作成している
const objA = {};
const objB = {};
// 生成されたオブジェクトは異なる参照となる
console.log(objA === objB); // => false

// 等価演算子（==）
// 等価演算子（==）はオペランド同士が異なる型の値であった場合に、 同じ型となるように暗黙的な型変換をしてから比較します。
// 文字列を数値に変換してから比較
console.log(1 == "1"); // => true
// "01"を数値にすると`1`となる
console.log(1 == "01"); // => true

// 例外的に、等価演算子（==）が使われるケースとして、nullとundefinedの比較があります。
const value = undefined; /* または null */
// === では2つの値と比較しないといけない
if (value === null || value === undefined) {
  console.log("valueがnullまたはundefinedである場合の処理");
}
// == では null と比較するだけでよい
if (value == null) {
  console.log("valueがnullまたはundefinedである場合の処理");
}

// ビット演算子
// ビット演算子では、オペランドである数値を符号付き32ビット整数（0と1からなる32個のビットの集合）として扱います。
console.log(00000000000000000000000000000001);

// ビット論理積（&）
// ビット論理積演算子（&）はビットごとのAND演算した結果を返します。 AND演算では、オペランドの各ビットがどちらも1の場合は1となり、それ以外の場合は0となります。
console.log(15 & 9); // => 9
// 同じ位の各ビット同士をAND演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1001
console.log(0b1111 & 0b1001); // => 0b1001

// ビット論理和（|）
// OR演算では、オペランドの各ビットがどちらか片方でも1の場合は1となり、両方とも0の場合は0となります。
console.log(15 | 9); // => 15
// 同じ位の各ビット同士をOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1111
console.log(0b1111 | 0b1001); // => 0b1111

// ビット排他的論理和（^）
// XOR演算では、オペランドのビットが異なるなら1、両方とも同じなら0となります。
console.log(15 ^ 9); // => 6
// 同じ位の各ビット同士をXOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 0110
console.log(0b1111 ^ 0b1001); // => 0b0110

// ビット否定（~）
// オペランドの各ビットを反転した値を返します。 これは1の補数として知られている値と同じものです。
console.log(~15); // => -16

// 文字列検索ではincludesメソッドを使用する
const str2 = "森木森";
if (str2.includes("木")) {
  console.log("値を見つけました");
}

// 左シフト演算子（<<）
// 左シフト演算子は、数値であるnumをbitの数だけ左へシフトします。 左にあふれたビットは破棄され、0のビットを右から詰めます。
// num << bit;
console.log(9 << 2); // => 36
console.log(0b1111 << 2); // => 0b11_1100

// ゼロ埋め右シフト演算子（>>>）
// ゼロ埋め右シフト演算子は、数値であるnumをbitの数だけ右へシフトするのは右シフト演算子（>>）と同じです。 異なる点としては右にあふれたビットは破棄され、0のビットを左から詰めます。
console.log(-9 >>> 2); // => 1073741821
//    1111_1111_1111_1111_1111_1111_1111_0111 >>> 2
// => 0011_1111_1111_1111_1111_1111_1111_1101

// 分割代入（Destructuring assignment）
const array = [1, 2];
const [a, b] = array;
console.log(a, b);

// 同様にオブジェクトも分割代入に対応しています。 オブジェクトの場合は、右辺のオブジェクトのプロパティ値を、左辺に対応するプロパティ名へ代入します。
const obj = {
  key: "value",
};
// プロパティ名`key`の値を、変数`key`として定義する
const { key } = obj;
console.log(key); // => "value"
